{"remainingRequest":"/root/lockhash/web-app/node_modules/thread-loader/dist/cjs.js!/root/lockhash/web-app/node_modules/babel-loader/lib/index.js!/root/lockhash/web-app/node_modules/eslint-loader/index.js??ref--13-0!/root/lockhash/web-app/src/modules/auth/vuex/actions.js","dependencies":[{"path":"/root/lockhash/web-app/src/modules/auth/vuex/actions.js","mtime":1553930101455},{"path":"/root/lockhash/web-app/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/root/lockhash/web-app/node_modules/thread-loader/dist/cjs.js","mtime":499162500000},{"path":"/root/lockhash/web-app/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/root/lockhash/web-app/node_modules/eslint-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import _Promise from \"/root/lockhash/web-app/node_modules/@babel/runtime-corejs2/core-js/promise\";\n// src is a alias. see client/build/webpack.base.conf.js\nimport { userTokenStorageKey } from '$config';\nimport * as services from '$modules/auth/services';\nimport localforage from 'localforage';\nimport { isEmpty } from 'lodash';\nimport * as TYPES from './mutations-types';\nexport var attemptLogin = function attemptLogin(_ref, payload) {\n  var dispatch = _ref.dispatch;\n  return services.postLogin(payload).then(function (data) {\n    dispatch('setToken', data.access_token);\n    return _Promise.resolve();\n  }).then(function () {\n    return dispatch('loadUser');\n  });\n};\nexport var attemptRegister = function attemptRegister(_ref2, payload) {\n  var dispatch = _ref2.dispatch;\n  return services.postRegister(payload).then(function (_ref3) {\n    var token = _ref3.token;\n    dispatch('setToken', token);\n    return _Promise.resolve();\n  }).then(function () {\n    return dispatch('loadUser');\n  });\n};\nexport var logout = function logout(_ref4) {\n  var dispatch = _ref4.dispatch;\n  return localforage.removeItem(userTokenStorageKey).then(dispatch('setToken', null)).then(dispatch('setUser', {}));\n};\nexport var setUser = function setUser(_ref5, user) {\n  var commit = _ref5.commit;\n  // Commit the mutations\n  commit(TYPES.SET_USER, user);\n\n  _Promise.resolve(user); // keep promise chain\n\n};\nexport var setToken = function setToken(_ref6, payload) {\n  var commit = _ref6.commit;\n  // prevent if payload is a object\n  var token = isEmpty(payload) ? null : payload.token || payload; // Commit the mutations\n\n  commit(TYPES.SET_TOKEN, token);\n  return _Promise.resolve(token); // keep promise chain\n};\nexport var checkUserToken = function checkUserToken(_ref7) {\n  var dispatch = _ref7.dispatch,\n      state = _ref7.state;\n\n  // If the token exists then all validation has already been done\n  if (!isEmpty(state.token)) {\n    return _Promise.resolve(state.token);\n  }\n  /**\n   * Token does not exist yet\n   * - Recover it from localstorage\n   * - Recover also the user, validating the token also\n   */\n\n\n  return localforage.getItem(userTokenStorageKey).then(function (token) {\n    if (isEmpty(token)) {\n      // Token is not saved in localstorage\n      return _Promise.reject('NO_TOKEN'); // Reject promise\n    } // Put the token in the vuex store\n\n\n    return dispatch('setToken', token); // keep promise chain\n  }) // With the token in hand, retrieves the user's data, validating the token\n  .then(function () {\n    return dispatch('loadUser');\n  });\n};\n/**\n * Retrieves updated user information\n * If something goes wrong, the user's token is probably invalid\n */\n\nexport var loadUser = function loadUser(_ref8) {\n  var dispatch = _ref8.dispatch;\n  return services.loadUserData() // store user's data\n  .then(function (user) {\n    return dispatch('setUser', user);\n  }).catch(logout);\n};",{"version":3,"sources":["/root/lockhash/web-app/src/modules/auth/vuex/actions.js"],"names":["userTokenStorageKey","services","localforage","isEmpty","TYPES","attemptLogin","payload","dispatch","postLogin","then","data","access_token","resolve","attemptRegister","postRegister","token","logout","removeItem","setUser","user","commit","SET_USER","setToken","SET_TOKEN","checkUserToken","state","getItem","reject","loadUser","loadUserData","catch"],"mappings":"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","sourcesContent":["// src is a alias. see client/build/webpack.base.conf.js\nimport { userTokenStorageKey } from '$config'\nimport * as services from '$modules/auth/services'\nimport localforage from 'localforage'\nimport { isEmpty } from 'lodash'\nimport * as TYPES from './mutations-types'\n\nexport const attemptLogin = ({ dispatch }, payload) =>\n  services\n    .postLogin(payload)\n    .then(data => {\n      dispatch('setToken', data.access_token)\n\n      return Promise.resolve()\n    })\n    .then(() => dispatch('loadUser'))\n\nexport const attemptRegister = ({ dispatch }, payload) =>\n  services\n    .postRegister(payload)\n    .then(({ token }) => {\n      dispatch('setToken', token)\n\n      return Promise.resolve()\n    })\n    .then(() => dispatch('loadUser'))\n\nexport const logout = ({ dispatch }) => {\n  return localforage\n    .removeItem(userTokenStorageKey)\n    .then(dispatch('setToken', null))\n    .then(dispatch('setUser', {}))\n}\n\nexport const setUser = ({ commit }, user) => {\n  // Commit the mutations\n  commit(TYPES.SET_USER, user)\n\n  Promise.resolve(user) // keep promise chain\n}\n\nexport const setToken = ({ commit }, payload) => {\n  // prevent if payload is a object\n  const token = isEmpty(payload) ? null : payload.token || payload\n\n  // Commit the mutations\n  commit(TYPES.SET_TOKEN, token)\n\n  return Promise.resolve(token) // keep promise chain\n}\n\nexport const checkUserToken = ({ dispatch, state }) => {\n  // If the token exists then all validation has already been done\n  if (!isEmpty(state.token)) {\n    return Promise.resolve(state.token)\n  }\n\n  /**\n   * Token does not exist yet\n   * - Recover it from localstorage\n   * - Recover also the user, validating the token also\n   */\n  return (\n    localforage\n      .getItem(userTokenStorageKey)\n      .then(token => {\n        if (isEmpty(token)) {\n          // Token is not saved in localstorage\n          return Promise.reject('NO_TOKEN') // Reject promise\n        }\n        // Put the token in the vuex store\n        return dispatch('setToken', token) // keep promise chain\n      })\n      // With the token in hand, retrieves the user's data, validating the token\n      .then(() => dispatch('loadUser'))\n  )\n}\n\n/**\n * Retrieves updated user information\n * If something goes wrong, the user's token is probably invalid\n */\nexport const loadUser = ({ dispatch }) =>\n  services\n    .loadUserData()\n    // store user's data\n    .then(user => dispatch('setUser', user))\n    .catch(logout)\n"]}]}